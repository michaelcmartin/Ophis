<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Preface</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Programming with Ophis"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="Programming with Ophis"
HREF="book1.html"><LINK
REL="NEXT"
TITLE="Getting a copy of Ophis"
HREF="x32.html"></HEAD
><BODY
CLASS="PREFACE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Programming with Ophis</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="book1.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x32.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="PREFACE"
><H1
><A
NAME="AEN10"
></A
>Preface</H1
><P
>    Ophis is an assembler for the 6502 microprocessor - the famous
    chip used in the vast majority of the classic 8-bit computers and
    consoles. Its primary design goals are code readability and output
    flexibility - Ophis has successfully been used to create programs
    for the Nintendo Entertainment System, the Atari 2600, and various
    8-bit Commodore and Apple machines.
  </P
><P
>    Ophis's syntax is noticably different from the formats
    traditionally used for these chips; it draws its syntactic
    inspiration primarily from the assemblers for more modern chips,
    where the role of tokens is determined more by what they're made
    of and their grammatical location on a line rather than their
    absolute position on a line. It also borrows the sophisticated
    methods of tracking the location of labels when writing relinkable
    code&#8212;Ophis expects that the final output it produces will have
    only a vague resemblance to the memory image when loaded. Most of
    the alternatives when Ophis was first designed would place
    instructions and data into a memory map and then dump that map.
  </P
><P
>    That said, there remain many actively used 6502 assemblers out
    there. If you're already a seasoned 6502 assembly programmer, or
    want to get your old sources built again, Ophis is likely not for
    you&#8212;however, if you are writing new code, or are new to the
    chip while still having other experience, then Ophis is a tool
    built with you in mind.
  </P
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN15"
>History of the project</A
></H1
><P
>      The Ophis project started on a lark back in 2001.  My graduate
      studies required me to learn Perl and Python, and I'd been
      playing around with Commodore 64 emulators in my spare time, so
      I decided to learn both languages by writing a simple
      cross-assembler for the 6502 chip the C64 used in both.
    </P
><P
>      The Perl one&#8212;uncreatively dubbed
      <SPAN
CLASS="QUOTE"
>"Perl65"</SPAN
>&#8212;was quickly abandoned, but the
      Python one saw more work. When it came time to name it, one of
      the things I had been hoping to do with the assembler was to
      produce working Apple II programs.  <SPAN
CLASS="QUOTE"
>"Ophis"</SPAN
> is
      Greek for <SPAN
CLASS="QUOTE"
>"snake"</SPAN
>, and a number of traditions also
      use it as the actual <I
CLASS="EMPHASIS"
>name</I
> of the serpent in
      the Garden of Eden.  So, Pythons, snakes, and stories involving
      really old Apples all combined to name the
      assembler.<A
NAME="AEN23"
HREF="#FTN.AEN23"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
    </P
><P
>      Ophis slowly grew in scope and power over the years, and by 2005
      was a very powerful, flexible macro assembler that saw more use
      than I'd expect.  In 2007 Ophis 1.0 was formally released.
      However, Ophis was written for Python 2.1 and this became more
      and more untenable as time has gone by. As I started receiving
      patches for parts of Ophis, and as I used it for some projects
      of my own, it became clear that Ophis needed to be modernized
      and to become better able to interoperate with other
      toolchains. It was this process that led to Ophis 2.
    </P
><P
>      After its release Ophis 2 was picked up by a number of
      developers working with actual hardware from the period,
      including prototype machines that never saw production. Some
      of their contributions have refined the code generators for
      version 2.1.
    </P
><P
>      At that point, the program was basically done, and very little
      changes for about five years. The world, however, moved on, and
      Python 2, my implementation language, was deprecated and
      rendered obsolete. That didn't change much about the 2.1
      release&#8212;Python 2 was still installed on non-Windows
      machines by default, and the Windows distribution was as a
      bundled .EXE file&#8212;but it threatened the viability of the
      program overall. In 2019, then, I converted the source base to
      the backwards-incompatible Python 3, in the hopes of
      future-proofing the system. Five years after
      <I
CLASS="EMPHASIS"
>that</I
>, enough bug reports and bug fixes had
      trickled in to justify a fresh release, and 2.2 was published in
      2024&#8212;a lightly polished update that now fit more neatly
      into the Python toolchains of the 2020s.
    </P
><P
>      In the twenty years since I first started this project, I've
      gained quite a bit more experience with programming the computer
      systems of the 1970s and 1980s. I have left this manual largely
      as it was in its 2014 edition, including its versions of the
      <I
CLASS="EMPHASIS"
>To HLL and Back</I
> essays I wrote using Ophis
      and Perl65 as example languages. I don't think I stand behind my
      design decisions back then as firmly as I did when I wrote those
      essays, but there's noting <I
CLASS="EMPHASIS"
>wrong</I
> with them
      either so I'm happy to leave them as a testament to my younger,
      brasher self.
    </P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN23"
HREF="f10.html#AEN23"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Ironically, cross-platform development
      for the Apple II is much less straightforward than for the
      Commodore 8-bits or ROM-based consoles, and it took many years
      after its release before it was actually used to write code
      deployed on any of the Apples which inspired its
      name.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x32.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Programming with Ophis</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Getting a copy of Ophis</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>